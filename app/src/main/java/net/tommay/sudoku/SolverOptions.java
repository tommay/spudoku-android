/*
  Source code is in UTF-8 encoding. The following symbols may appear, among others:
  α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ ς σ τ υ φ χ ψ ω « • ¦ » ∀ ∃ ∷ … → ← ﬁ ﬂ ƒ
  If you can't read this, you're out of luck. This code was generated with the frege compiler version 3.24.141
  from ./net/tommay/sudoku/SolverOptions.fr Do not edit this file! Instead, edit the source file and recompile.
*/

package net.tommay.sudoku;

import frege.run7.Func;
import frege.run7.Lazy;
import frege.run7.Thunk;
import frege.run.Kind;
import frege.run.RunTM;
import frege.runtime.Meta;
import frege.runtime.Phantom.RealWorld;
import frege.Prelude;
import frege.control.Category;
import frege.control.Semigroupoid;
import frege.java.IO;
import frege.java.Lang;
import frege.java.Util;
import frege.java.util.Regex;
import frege.prelude.Maybe;
import frege.prelude.PreludeArrays;
import frege.prelude.PreludeBase;
import frege.prelude.PreludeIO;
import frege.prelude.PreludeList;
import frege.prelude.PreludeMonad;
import frege.prelude.PreludeText;

@SuppressWarnings("unused")
@Meta.FregePackage(
  source="./net/tommay/sudoku/SolverOptions.fr", time=1481937166618L, jmajor=1, jminor=7,
  imps={
    "frege.Prelude", "frege.prelude.PreludeArrays", "frege.prelude.PreludeBase", "frege.prelude.PreludeIO",
    "frege.prelude.PreludeList", "frege.prelude.PreludeMonad", "frege.prelude.PreludeText", "frege.java.util.Regex"
  },
  nmss={"Prelude", "PreludeArrays", "PreludeBase", "PreludeIO", "PreludeList", "PreludeMonad", "PreludeText", "Regexp"},
  symas={}, symcs={}, symis={},
  symts={
    @Meta.SymT(
      offset=95, name=@Meta.QName(kind=0, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions"), typ=0,
      kind=5,
      cons={
        @Meta.SymD(
          offset=111,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="SolverOptions"
          ),
          cid=0, typ=3,
          fields={
            @Meta.Field(name="useHeuristics", offset=129, sigma=1, strict=false),
            @Meta.Field(name="heuristics", offset=154, sigma=2, strict=false),
            @Meta.Field(name="usePermanentTrickySets", offset=183, sigma=1, strict=false),
            @Meta.Field(name="useGuessing", offset=217, sigma=1, strict=false)
          },
          priv=true, publik=false
        )
      },
      lnks={},
      funs={
        @Meta.SymV(
          offset=184,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="usePermanentTrickySets"
          ),
          stri="s(s)", sig=4, depth=1, rkind=49, doc="access field @usePermanentTrickySets@"
        ),
        @Meta.SymV(
          offset=130,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="useHeuristics"
          ),
          stri="s(s)", sig=4, depth=1, rkind=49, doc="access field @useHeuristics@"
        ),
        @Meta.SymV(
          offset=184,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="upd$usePermanentTrickySets"
          ),
          stri="s(su)", sig=5, depth=2, rkind=49, doc="update field @usePermanentTrickySets@"
        ),
        @Meta.SymV(
          offset=130,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="upd$useHeuristics"
          ),
          stri="s(su)", sig=5, depth=2, rkind=49, doc="update field @useHeuristics@"
        ),
        @Meta.SymV(
          offset=155,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="upd$heuristics"
          ),
          stri="s(su)", sig=6, depth=2, rkind=49, doc="update field @heuristics@"
        ),
        @Meta.SymV(
          offset=218,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="upd$useGuessing"
          ),
          stri="s(su)", sig=5, depth=2, rkind=49, doc="update field @useGuessing@"
        ),
        @Meta.SymV(
          offset=218,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="useGuessing"),
          stri="s(s)", sig=4, depth=1, rkind=49, doc="access field @useGuessing@"
        ),
        @Meta.SymV(
          offset=184,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="has$usePermanentTrickySets"
          ),
          stri="s(u)", sig=8, depth=1, rkind=49, doc="check if constructor has field @usePermanentTrickySets@"
        ),
        @Meta.SymV(
          offset=218,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="has$useGuessing"
          ),
          stri="s(u)", sig=8, depth=1, rkind=49, doc="check if constructor has field @useGuessing@"
        ),
        @Meta.SymV(
          offset=130,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="has$useHeuristics"
          ),
          stri="s(u)", sig=8, depth=1, rkind=49, doc="check if constructor has field @useHeuristics@"
        ),
        @Meta.SymV(
          offset=184,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="chg$usePermanentTrickySets"
          ),
          stri="s(ss)", sig=10, depth=2, rkind=49, doc="change field @usePermanentTrickySets@"
        ),
        @Meta.SymV(
          offset=130,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="chg$useHeuristics"
          ),
          stri="s(ss)", sig=10, depth=2, rkind=49, doc="change field @useHeuristics@"
        ),
        @Meta.SymV(
          offset=155,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="has$heuristics"
          ),
          stri="s(u)", sig=8, depth=1, rkind=49, doc="check if constructor has field @heuristics@"
        ),
        @Meta.SymV(
          offset=155,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="chg$heuristics"
          ),
          stri="s(ss)", sig=12, depth=2, rkind=49, doc="change field @heuristics@"
        ),
        @Meta.SymV(
          offset=218,
          name=@Meta.QName(
            kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="chg$useGuessing"
          ),
          stri="s(ss)", sig=10, depth=2, rkind=49, doc="change field @useGuessing@"
        ),
        @Meta.SymV(
          offset=155,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions", member="heuristics"),
          stri="s(s)", sig=13, depth=1, rkind=49, doc="access field @heuristics@"
        )
      },
      prod=true
    ),
    @Meta.SymT(
      offset=2054, name=@Meta.QName(kind=0, pack="net.tommay.sudoku.SolverOptions", base="Heuristic"), typ=14,
      kind=5,
      cons={
        @Meta.SymD(
          offset=2124,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="Tricky"), cid=5,
          typ=14, fields={}
        ),
        @Meta.SymD(
          offset=2093,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="MissingTwo"),
          cid=2, typ=14, fields={}
        ),
        @Meta.SymD(
          offset=2106,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="Needed"), cid=3,
          typ=14, fields={}
        ),
        @Meta.SymD(
          offset=2115,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="Forced"), cid=4,
          typ=14, fields={}
        ),
        @Meta.SymD(
          offset=2068,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="EasyPeasy"), cid=0,
          typ=14, fields={}
        ),
        @Meta.SymD(
          offset=2080,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="MissingOne"),
          cid=1, typ=14, fields={}
        )
      },
      lnks={}, funs={}, isEnum=true
    )
  },
  symvs={
    @Meta.SymV(
      offset=2563, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="noGuessing"), stri="u",
      sig=0, depth=0, rkind=36
    ),
    @Meta.SymV(
      offset=2132, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="new"), stri="s(uuu)",
      sig=15, depth=3, rkind=49
    ),
    @Meta.SymV(
      offset=2406, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="all"), stri="u",
      sig=0, depth=0, rkind=36
    )
  },
  symls={
    @Meta.SymL(
      offset=2124, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="Tricky"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="Tricky")
    ),
    @Meta.SymL(
      offset=2106, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="Needed"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="Needed")
    ),
    @Meta.SymL(
      offset=2080, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="MissingOne"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="MissingOne")
    ),
    @Meta.SymL(
      offset=2093, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="MissingTwo"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="MissingTwo")
    ),
    @Meta.SymL(
      offset=2115, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="Forced"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="Forced")
    ),
    @Meta.SymL(
      offset=2068, name=@Meta.QName(pack="net.tommay.sudoku.SolverOptions", base="EasyPeasy"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.SolverOptions", base="Heuristic", member="EasyPeasy")
    )
  },
  taus={
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="net.tommay.sudoku.SolverOptions", base="SolverOptions")}),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="Bool")}),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="[]")}),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="net.tommay.sudoku.SolverOptions", base="Heuristic")}),
    @Meta.Tau(kind=0, suba=2, subb=3), @Meta.Tau(kind=9), @Meta.Tau(suba=5, tvar="α"),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="->")}),
    @Meta.Tau(kind=0, suba=7, subb=1), @Meta.Tau(kind=0, suba=8, subb=1), @Meta.Tau(kind=0, suba=7, subb=4),
    @Meta.Tau(kind=0, suba=10, subb=4)
  },
  rhos={
    @Meta.Rho(rhofun=false, rhotau=0), @Meta.Rho(rhofun=false, rhotau=1), @Meta.Rho(rhofun=false, rhotau=4),
    @Meta.Rho(sigma=1, rhotau=0), @Meta.Rho(sigma=1, rhotau=3), @Meta.Rho(sigma=2, rhotau=4),
    @Meta.Rho(sigma=1, rhotau=5), @Meta.Rho(sigma=0, rhotau=1), @Meta.Rho(sigma=0, rhotau=3),
    @Meta.Rho(sigma=2, rhotau=0), @Meta.Rho(sigma=0, rhotau=9), @Meta.Rho(rhofun=false, rhotau=6),
    @Meta.Rho(sigma=7, rhotau=1), @Meta.Rho(rhofun=false, rhotau=9), @Meta.Rho(sigma=9, rhotau=0),
    @Meta.Rho(sigma=0, rhotau=14), @Meta.Rho(rhofun=false, rhotau=11), @Meta.Rho(sigma=11, rhotau=0),
    @Meta.Rho(sigma=0, rhotau=17), @Meta.Rho(sigma=0, rhotau=2), @Meta.Rho(rhofun=false, rhotau=3)
  },
  sigmas={
    @Meta.Sigma(rho=0), @Meta.Sigma(rho=1), @Meta.Sigma(rho=2), @Meta.Sigma(rho=6), @Meta.Sigma(rho=7),
    @Meta.Sigma(rho=8), @Meta.Sigma(rho=10), @Meta.Sigma(rho=11), @Meta.Sigma(bound={"α"}, kinds={5}, rho=12),
    @Meta.Sigma(rho=13), @Meta.Sigma(rho=15), @Meta.Sigma(rho=16), @Meta.Sigma(rho=18), @Meta.Sigma(rho=19),
    @Meta.Sigma(rho=20), @Meta.Sigma(rho=5)
  },
  exprs={@Meta.Expr()}
)
final public class SolverOptions  {
  



final public static class TSolverOptions implements frege.runtime.Value, Lazy<TSolverOptions> {
  private TSolverOptions(
    final Lazy<Boolean> arg$1, final Lazy<PreludeBase.TList<Short>> arg$2, final Lazy<Boolean> arg$3, final Lazy<Boolean> arg$4
  ) {
    mem$useHeuristics = Thunk.<Boolean>shared(arg$1);
    mem$heuristics = Thunk.<PreludeBase.TList<Short>>shared(arg$2);
    mem$usePermanentTrickySets = Thunk.<Boolean>shared(arg$3);
    mem$useGuessing = Thunk.<Boolean>shared(arg$4);
  }
  final public int constructor() {
    return 0;
  }
  final public static TSolverOptions mk(
    final Lazy<Boolean> arg$1, final Lazy<PreludeBase.TList<Short>> arg$2, final Lazy<Boolean> arg$3, final Lazy<Boolean> arg$4
  ) {
    return new TSolverOptions(arg$1, arg$2, arg$3, arg$4);
  }
  final public Lazy<Boolean> mem$useHeuristics  ;
  final public Lazy<PreludeBase.TList<Short>> mem$heuristics  ;
  final public Lazy<Boolean> mem$usePermanentTrickySets  ;
  final public Lazy<Boolean> mem$useGuessing  ;
  final public TSolverOptions call() {
    return this;
  }
  final public boolean isShared() {
    return true;
  }
  final public Thunk<TSolverOptions> asThunk() {
    return null;
  }
  @SuppressWarnings("unchecked") final public TSolverOptions simsalabim() {
    return (TSolverOptions)this;
  }
  final public static boolean usePermanentTrickySets(final TSolverOptions arg$1) {
    final boolean a3$7662 = (boolean)arg$1.mem$usePermanentTrickySets.call();
    return a3$7662;
  }
  final public static boolean useHeuristics(final TSolverOptions arg$1) {
    final boolean a1$7642 = (boolean)arg$1.mem$useHeuristics.call();
    return a1$7642;
  }
  final public static TSolverOptions upd$usePermanentTrickySets(final TSolverOptions arg$1, final Lazy<Boolean> arg$2) {
    return TSolverOptions.mk(arg$1.mem$useHeuristics, arg$1.mem$heuristics, arg$2, arg$1.mem$useGuessing);
  }
  final public static TSolverOptions upd$useHeuristics(final TSolverOptions arg$1, final Lazy<Boolean> arg$2) {
    return TSolverOptions.mk(arg$2, arg$1.mem$heuristics, arg$1.mem$usePermanentTrickySets, arg$1.mem$useGuessing);
  }
  final public static TSolverOptions upd$heuristics(final TSolverOptions arg$1, final Lazy<PreludeBase.TList<Short>> arg$2) {
    return TSolverOptions.mk(arg$1.mem$useHeuristics, arg$2, arg$1.mem$usePermanentTrickySets, arg$1.mem$useGuessing);
  }
  final public static TSolverOptions upd$useGuessing(final TSolverOptions arg$1, final Lazy<Boolean> arg$2) {
    return TSolverOptions.mk(arg$1.mem$useHeuristics, arg$1.mem$heuristics, arg$1.mem$usePermanentTrickySets, arg$2);
  }
  final public static boolean useGuessing(final TSolverOptions arg$1) {
    final boolean a4$7627 = (boolean)arg$1.mem$useGuessing.call();
    return a4$7627;
  }
  final public static <α> boolean has$usePermanentTrickySets(final Lazy<α> arg$1) {
    return true;
  }
  final public static <α> boolean has$useGuessing(final Lazy<α> arg$1) {
    return true;
  }
  final public static <α> boolean has$useHeuristics(final Lazy<α> arg$1) {
    return true;
  }
  final public static TSolverOptions chg$usePermanentTrickySets(
    final TSolverOptions arg$1, final Func.U<Boolean, Boolean> arg$2
  ) {
    return TSolverOptions.mk(
              arg$1.mem$useHeuristics, arg$1.mem$heuristics,
              Thunk.<Boolean>nested(
                    new Lazy.D<Lazy<Boolean>>() {
                      public Lazy<Boolean> call() {
                        return arg$2.apply(arg$1.mem$usePermanentTrickySets);
                      }
                    }
                  ),
              arg$1.mem$useGuessing
            );
  }
  final public static TSolverOptions chg$useHeuristics(final TSolverOptions arg$1, final Func.U<Boolean, Boolean> arg$2) {
    return TSolverOptions.mk(
              Thunk.<Boolean>nested(
                    new Lazy.D<Lazy<Boolean>>() {
                      public Lazy<Boolean> call() {
                        return arg$2.apply(arg$1.mem$useHeuristics);
                      }
                    }
                  ),
              arg$1.mem$heuristics, arg$1.mem$usePermanentTrickySets, arg$1.mem$useGuessing
            );
  }
  final public static <α> boolean has$heuristics(final Lazy<α> arg$1) {
    return true;
  }
  final public static TSolverOptions chg$heuristics(
    final TSolverOptions arg$1, final Func.U<PreludeBase.TList<Short>, PreludeBase.TList<Short>> arg$2
  ) {
    return TSolverOptions.mk(
              arg$1.mem$useHeuristics,
              Thunk.<PreludeBase.TList<Short>>nested(
                    new Lazy.D<Lazy<PreludeBase.TList<Short>>>() {
                      public Lazy<PreludeBase.TList<Short>> call() {
                        return arg$2.apply(arg$1.mem$heuristics);
                      }
                    }
                  ),
              arg$1.mem$usePermanentTrickySets, arg$1.mem$useGuessing
            );
  }
  final public static TSolverOptions chg$useGuessing(final TSolverOptions arg$1, final Func.U<Boolean, Boolean> arg$2) {
    return TSolverOptions.mk(
              arg$1.mem$useHeuristics, arg$1.mem$heuristics, arg$1.mem$usePermanentTrickySets,
              Thunk.<Boolean>nested(
                    new Lazy.D<Lazy<Boolean>>() {
                      public Lazy<Boolean> call() {
                        return arg$2.apply(arg$1.mem$useGuessing);
                      }
                    }
                  )
            );
  }
  final public static PreludeBase.TList<Short> heuristics(final TSolverOptions arg$1) {
    final PreludeBase.TList<Short> a2$7607 = arg$1.mem$heuristics.call();
    return a2$7607;
  }
}
final public static class THeuristic  {
  final public static short Tricky = 5;
  final public static short MissingTwo = 2;
  final public static short Needed = 3;
  final public static short Forced = 4;
  final public static short EasyPeasy = 0;
  final public static short MissingOne = 1;
}
final public static TSolverOptions $new(
  final Lazy<PreludeBase.TList<Short>> arg$1, final Lazy<Boolean> arg$2, final Lazy<Boolean> arg$3
) {
  return TSolverOptions.mk(
            Thunk.<Boolean>shared(
                  new Lazy.D<Boolean>() {
                    public Boolean call() {
                      return ! PreludeList.IListView_$lbrack$rbrack.<Short>$null(arg$1.call());
                    }
                  }
                ),
            arg$1, arg$2, arg$3
          );
}
final public static Lazy<TSolverOptions> noGuessing = Thunk.<TSolverOptions>shared(
      new Lazy.D<TSolverOptions>() {
        public TSolverOptions call() {
          return SolverOptions.$new(
                    PreludeBase.TList.DCons.<Short>mk(
                          Thunk.<Short>lazy(THeuristic.Forced),
                          PreludeBase.TList.DCons.<Short>mk(
                                Thunk.<Short>lazy(THeuristic.Needed),
                                PreludeBase.TList.DCons.<Short>mk(
                                      Thunk.<Short>lazy(THeuristic.Tricky), PreludeBase.TList.DList.<Short>mk()
                                    )
                              )
                        ),
                    Thunk.<Boolean>lazy(false), Thunk.<Boolean>lazy(false)
                  );
        }
      }
    );
final public static Lazy<TSolverOptions> all = Thunk.<TSolverOptions>shared(
      new Lazy.D<TSolverOptions>() {
        public TSolverOptions call() {
          return SolverOptions.$new(PreludeBase.TList.DList.<Short>mk(), Thunk.<Boolean>lazy(false), Thunk.<Boolean>lazy(true));
        }
      }
    );

}
