/*
  Source code is in UTF-8 encoding. The following symbols may appear, among others:
  α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ ς σ τ υ φ χ ψ ω « • ¦ » ∀ ∃ ∷ … → ← ﬁ ﬂ ƒ
  If you can't read this, you're out of luck. This code was generated with the frege compiler version 3.24.141
  from ./net/tommay/sudoku/Unknown.fr Do not edit this file! Instead, edit the source file and recompile.
*/

package net.tommay.sudoku;

import frege.run7.Func;
import frege.run7.Lazy;
import frege.run7.Thunk;
import frege.run.Kind;
import frege.run.RunTM;
import frege.runtime.Meta;
import frege.runtime.Phantom.RealWorld;
import frege.Prelude;
import frege.control.Category;
import frege.control.Semigroupoid;
import frege.data.Bits;
import frege.data.Monoid;
import frege.java.IO;
import frege.java.Lang;
import frege.java.Util;
import frege.java.util.Regex;
import frege.prelude.Maybe;
import frege.prelude.PreludeArrays;
import frege.prelude.PreludeBase;
import frege.prelude.PreludeIO;
import frege.prelude.PreludeList;
import frege.prelude.PreludeMonad;
import frege.prelude.PreludeText;
import net.tommay.sudoku.Digit;

@SuppressWarnings("unused")
@Meta.FregePackage(
  source="./net/tommay/sudoku/Unknown.fr", time=1481937169938L, jmajor=1, jminor=7,
  imps={
    "frege.data.Bits", "net.tommay.sudoku.Digit", "frege.Prelude", "frege.prelude.PreludeArrays",
    "frege.prelude.PreludeBase", "frege.prelude.PreludeIO", "frege.prelude.PreludeList", "frege.prelude.PreludeMonad",
    "frege.prelude.PreludeText", "frege.java.util.Regex"
  },
  nmss={
    "Bits", "Digit", "Prelude", "PreludeArrays", "PreludeBase", "PreludeIO", "PreludeList", "PreludeMonad",
    "PreludeText", "Regexp"
  },
  symas={}, symcs={},
  symis={
    @Meta.SymI(
      offset=338, name=@Meta.QName(kind=0, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown"),
      clas=@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="Eq"), typ=0, lnks={},
      funs={
        @Meta.SymV(
          offset=497, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown", member="hashCode"),
          stri="s(s)", sig=1, depth=1, rkind=49
        ),
        @Meta.SymV(
          offset=338, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown", member="!="),
          stri="s(ss)", sig=2, depth=2, rkind=49, doc="inherited from 'Eq.!='", op=95
        ),
        @Meta.SymV(
          offset=371, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown", member="=="),
          stri="s(ss)", sig=2, depth=2, rkind=49, op=95
        )
      }
    )
  },
  symts={
    @Meta.SymT(
      offset=115, name=@Meta.QName(kind=0, pack="net.tommay.sudoku.Unknown", base="Unknown"), typ=0,
      kind=3,
      cons={
        @Meta.SymD(
          offset=125, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="Unknown"),
          cid=0, typ=4,
          fields={
            @Meta.Field(name="cellNumber", offset=138, sigma=3), @Meta.Field(name="row", offset=160, sigma=3),
            @Meta.Field(name="col", offset=175, sigma=3), @Meta.Field(name="square", offset=190, sigma=3),
            @Meta.Field(name="possible", offset=208, sigma=3)
          }
        )
      },
      lnks={
        @Meta.SymL(
          offset=497, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="hashCode"),
          alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown", member="hashCode")
        ),
        @Meta.SymL(
          offset=338, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="!="),
          alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown", member="!=")
        ),
        @Meta.SymL(
          offset=371, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="=="),
          alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Eq_Unknown", member="==")
        )
      },
      funs={
        @Meta.SymV(
          offset=191, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="upd$square"),
          stri="s(ss)", sig=5, depth=2, rkind=49, doc="update field @square@"
        ),
        @Meta.SymV(
          offset=161, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="upd$row"),
          stri="s(ss)", sig=5, depth=2, rkind=49, doc="update field @row@"
        ),
        @Meta.SymV(
          offset=176, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="upd$col"),
          stri="s(ss)", sig=5, depth=2, rkind=49, doc="update field @col@"
        ),
        @Meta.SymV(
          offset=209, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="upd$possible"),
          stri="s(ss)", sig=5, depth=2, rkind=49, doc="update field @possible@"
        ),
        @Meta.SymV(
          offset=191, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="square"),
          stri="s(s)", sig=1, depth=1, rkind=49, doc="access field @square@"
        ),
        @Meta.SymV(
          offset=161, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="row"),
          stri="s(s)", sig=1, depth=1, rkind=49, doc="access field @row@"
        ),
        @Meta.SymV(
          offset=161, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="has$row"),
          stri="s(u)", sig=7, depth=1, rkind=49, doc="check if constructor has field @row@"
        ),
        @Meta.SymV(
          offset=191, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="has$square"),
          stri="s(u)", sig=7, depth=1, rkind=49, doc="check if constructor has field @square@"
        ),
        @Meta.SymV(
          offset=176, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="has$col"),
          stri="s(u)", sig=7, depth=1, rkind=49, doc="check if constructor has field @col@"
        ),
        @Meta.SymV(
          offset=209, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="has$possible"),
          stri="s(u)", sig=7, depth=1, rkind=49, doc="check if constructor has field @possible@"
        ),
        @Meta.SymV(
          offset=209, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="possible"),
          stri="s(s)", sig=1, depth=1, rkind=49, doc="access field @possible@"
        ),
        @Meta.SymV(
          offset=139,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="upd$cellNumber"),
          stri="s(ss)", sig=5, depth=2, rkind=49, doc="update field @cellNumber@"
        ),
        @Meta.SymV(
          offset=176, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="col"),
          stri="s(s)", sig=1, depth=1, rkind=49, doc="access field @col@"
        ),
        @Meta.SymV(
          offset=161, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="chg$row"),
          stri="s(ss)", sig=9, depth=2, rkind=49, doc="change field @row@"
        ),
        @Meta.SymV(
          offset=191, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="chg$square"),
          stri="s(ss)", sig=9, depth=2, rkind=49, doc="change field @square@"
        ),
        @Meta.SymV(
          offset=176, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="chg$col"),
          stri="s(ss)", sig=9, depth=2, rkind=49, doc="change field @col@"
        ),
        @Meta.SymV(
          offset=209, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="chg$possible"),
          stri="s(ss)", sig=9, depth=2, rkind=49, doc="change field @possible@"
        ),
        @Meta.SymV(
          offset=139, name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="cellNumber"),
          stri="s(s)", sig=1, depth=1, rkind=49, doc="access field @cellNumber@"
        ),
        @Meta.SymV(
          offset=139,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="chg$cellNumber"),
          stri="s(ss)", sig=9, depth=2, rkind=49, doc="change field @cellNumber@"
        ),
        @Meta.SymV(
          offset=139,
          name=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="has$cellNumber"),
          stri="s(u)", sig=7, depth=1, rkind=49, doc="check if constructor has field @cellNumber@"
        )
      },
      prod=true
    )
  },
  symvs={
    @Meta.SymV(
      offset=1630, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="removeDigitFromPossible"), stri="s(ss)",
      sig=10, depth=2, rkind=49
    ),
    @Meta.SymV(
      offset=961, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="place"), stri="s(uss)",
      sig=11, depth=3, rkind=49
    ),
    @Meta.SymV(
      offset=1415, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="numPossible"), stri="s(s)",
      sig=1, depth=1, rkind=49
    ),
    @Meta.SymV(
      offset=692, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="new"), stri="s(s)",
      sig=12, depth=1, rkind=49
    ),
    @Meta.SymV(
      offset=1505, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="isDigitPossible"), stri="s(ss)",
      sig=13, depth=2, rkind=49
    ),
    @Meta.SymV(
      offset=1893, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="getPossibleList"), stri="s(su)",
      sig=14, depth=2, rkind=185
    ),
    @Meta.SymV(
      offset=1795, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="getPossible"), stri="s(s)",
      sig=15, depth=1, rkind=49
    )
  },
  symls={
    @Meta.SymL(
      offset=125, name=@Meta.QName(pack="net.tommay.sudoku.Unknown", base="Unknown"),
      alias=@Meta.QName(kind=2, pack="net.tommay.sudoku.Unknown", base="Unknown", member="Unknown")
    )
  },
  taus={
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="net.tommay.sudoku.Unknown", base="Unknown")}),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="Int")}),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="Bool")}),
    @Meta.Tau(kind=9), @Meta.Tau(suba=3, tvar="α"),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="->")}),
    @Meta.Tau(kind=0, suba=5, subb=1), @Meta.Tau(kind=0, suba=6, subb=1),
    @Meta.Tau(kind=2, suba=0, tcon={@Meta.QName(kind=0, pack="frege.prelude.PreludeBase", base="[]")}),
    @Meta.Tau(kind=0, suba=8, subb=1)
  },
  rhos={
    @Meta.Rho(rhofun=false, rhotau=0), @Meta.Rho(rhofun=false, rhotau=1), @Meta.Rho(sigma=0, rhotau=1),
    @Meta.Rho(rhofun=false, rhotau=2), @Meta.Rho(sigma=0, rhotau=3), @Meta.Rho(sigma=0, rhotau=4),
    @Meta.Rho(sigma=3, rhotau=0), @Meta.Rho(sigma=3, rhotau=6), @Meta.Rho(sigma=3, rhotau=7),
    @Meta.Rho(sigma=3, rhotau=8), @Meta.Rho(sigma=3, rhotau=9), @Meta.Rho(sigma=0, rhotau=6),
    @Meta.Rho(rhofun=false, rhotau=4), @Meta.Rho(sigma=6, rhotau=3), @Meta.Rho(rhofun=false, rhotau=7),
    @Meta.Rho(sigma=8, rhotau=0), @Meta.Rho(sigma=0, rhotau=15), @Meta.Rho(sigma=0, rhotau=0),
    @Meta.Rho(sigma=3, rhotau=17), @Meta.Rho(sigma=3, rhotau=18), @Meta.Rho(sigma=3, rhotau=4),
    @Meta.Rho(rhofun=false, rhotau=9), @Meta.Rho(sigma=3, rhotau=21), @Meta.Rho(sigma=3, rhotau=22),
    @Meta.Rho(sigma=0, rhotau=21)
  },
  sigmas={
    @Meta.Sigma(rho=0), @Meta.Sigma(rho=2), @Meta.Sigma(rho=5), @Meta.Sigma(rho=1), @Meta.Sigma(rho=10),
    @Meta.Sigma(rho=11), @Meta.Sigma(rho=12), @Meta.Sigma(bound={"α"}, kinds={3}, rho=13), @Meta.Sigma(rho=14),
    @Meta.Sigma(rho=16), @Meta.Sigma(rho=18), @Meta.Sigma(rho=19), @Meta.Sigma(rho=6), @Meta.Sigma(rho=20),
    @Meta.Sigma(rho=23), @Meta.Sigma(rho=24)
  },
  exprs={@Meta.Expr()}
)
final public class Unknown  {
  


final public static class IEq_Unknown implements PreludeBase.CEq<TUnknown> {
  public IEq_Unknown() {}
  final public static IEq_Unknown it = new IEq_Unknown();
  @Override final public int ƒhashCode(final Lazy<TUnknown> arg$1) {
    return IEq_Unknown.hashCode(arg$1.call());
  }
  @Override final public boolean ƒ$excl$eq(final Lazy<TUnknown> arg$1, final Lazy<TUnknown> arg$2) {
    return IEq_Unknown.$excl$eq(arg$1.call(), arg$2.call());
  }
  @Override final public boolean ƒ$eq$eq(final Lazy<TUnknown> arg$1, final Lazy<TUnknown> arg$2) {
    return IEq_Unknown.$eq$eq(arg$1.call(), arg$2.call());
  }
  final public static int hashCode(final TUnknown arg$1) {
    return (TUnknown.cellNumber(arg$1) * 23) + PreludeBase.IEq_Int.hashCode(TUnknown.possible(arg$1));
  }
  final public static boolean $excl$eq(final TUnknown arg$1, final TUnknown arg$2) {
    if (IEq_Unknown.$eq$eq(arg$1, arg$2)) {
      return false;
    }
    else {
      return true;
    }
  }
  final public static boolean $eq$eq(final TUnknown arg$1, final TUnknown arg$2) {
    return (TUnknown.cellNumber(arg$1) == TUnknown.cellNumber(arg$2)) && (TUnknown.possible(
              arg$1
            ) == TUnknown.possible(arg$2));
  }
}
final public static class TUnknown implements frege.runtime.Value, Lazy<TUnknown> {
  private TUnknown(final int arg$1, final int arg$2, final int arg$3, final int arg$4, final int arg$5) {
    mem$cellNumber = arg$1;
    mem$row = arg$2;
    mem$col = arg$3;
    mem$square = arg$4;
    mem$possible = arg$5;
  }
  final public int constructor() {
    return 0;
  }
  final public static TUnknown mk(final int arg$1, final int arg$2, final int arg$3, final int arg$4, final int arg$5) {
    return new TUnknown(arg$1, arg$2, arg$3, arg$4, arg$5);
  }
  final public int mem$cellNumber  ;
  final public int mem$row  ;
  final public int mem$col  ;
  final public int mem$square  ;
  final public int mem$possible  ;
  final public TUnknown call() {
    return this;
  }
  final public boolean isShared() {
    return true;
  }
  final public Thunk<TUnknown> asThunk() {
    return null;
  }
  @SuppressWarnings("unchecked") final public TUnknown simsalabim() {
    return (TUnknown)this;
  }
  final public static TUnknown upd$square(final TUnknown arg$1, final int arg$2) {
    final int a5$8141 = arg$1.mem$possible;
    final int a3$8139 = arg$1.mem$col;
    final int a2$8138 = arg$1.mem$row;
    final int a1$8137 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8137, a2$8138, a3$8139, arg$2, a5$8141);
  }
  final public static TUnknown upd$row(final TUnknown arg$1, final int arg$2) {
    final int a5$8120 = arg$1.mem$possible;
    final int a4$8119 = arg$1.mem$square;
    final int a3$8118 = arg$1.mem$col;
    final int a1$8116 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8116, arg$2, a3$8118, a4$8119, a5$8120);
  }
  final public static TUnknown upd$col(final TUnknown arg$1, final int arg$2) {
    final int a5$8078 = arg$1.mem$possible;
    final int a4$8077 = arg$1.mem$square;
    final int a2$8075 = arg$1.mem$row;
    final int a1$8074 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8074, a2$8075, arg$2, a4$8077, a5$8078);
  }
  final public static TUnknown upd$possible(final TUnknown arg$1, final int arg$2) {
    final int a4$8098 = arg$1.mem$square;
    final int a3$8097 = arg$1.mem$col;
    final int a2$8096 = arg$1.mem$row;
    final int a1$8095 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8095, a2$8096, a3$8097, a4$8098, arg$2);
  }
  final public static int square(final TUnknown arg$1) {
    final int a4$8133 = arg$1.mem$square;
    return a4$8133;
  }
  final public static int row(final TUnknown arg$1) {
    final int a2$8110 = arg$1.mem$row;
    return a2$8110;
  }
  final public static <α> boolean has$row(final Lazy<α> arg$1) {
    return true;
  }
  final public static <α> boolean has$square(final Lazy<α> arg$1) {
    return true;
  }
  final public static <α> boolean has$col(final Lazy<α> arg$1) {
    return true;
  }
  final public static <α> boolean has$possible(final Lazy<α> arg$1) {
    return true;
  }
  final public static int possible(final TUnknown arg$1) {
    final int a5$8092 = arg$1.mem$possible;
    return a5$8092;
  }
  final public static TUnknown upd$cellNumber(final TUnknown arg$1, final int arg$2) {
    final int a5$8057 = arg$1.mem$possible;
    final int a4$8056 = arg$1.mem$square;
    final int a3$8055 = arg$1.mem$col;
    final int a2$8054 = arg$1.mem$row;
    return TUnknown.mk(arg$2, a2$8054, a3$8055, a4$8056, a5$8057);
  }
  final public static int col(final TUnknown arg$1) {
    final int a3$8069 = arg$1.mem$col;
    return a3$8069;
  }
  final public static TUnknown chg$row(final TUnknown arg$1, final Func.U<Integer, Integer> arg$2) {
    final int a5$8127 = arg$1.mem$possible;
    final int a4$8126 = arg$1.mem$square;
    final int a3$8125 = arg$1.mem$col;
    final int a1$8123 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8123, (int)arg$2.apply(Thunk.<Integer>lazy(arg$1.mem$row)).call(), a3$8125, a4$8126, a5$8127);
  }
  final public static TUnknown chg$square(final TUnknown arg$1, final Func.U<Integer, Integer> arg$2) {
    final int a5$8148 = arg$1.mem$possible;
    final int a3$8146 = arg$1.mem$col;
    final int a2$8145 = arg$1.mem$row;
    final int a1$8144 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8144, a2$8145, a3$8146, (int)arg$2.apply(Thunk.<Integer>lazy(arg$1.mem$square)).call(), a5$8148);
  }
  final public static TUnknown chg$col(final TUnknown arg$1, final Func.U<Integer, Integer> arg$2) {
    final int a5$8085 = arg$1.mem$possible;
    final int a4$8084 = arg$1.mem$square;
    final int a2$8082 = arg$1.mem$row;
    final int a1$8081 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8081, a2$8082, (int)arg$2.apply(Thunk.<Integer>lazy(arg$1.mem$col)).call(), a4$8084, a5$8085);
  }
  final public static TUnknown chg$possible(final TUnknown arg$1, final Func.U<Integer, Integer> arg$2) {
    final int a4$8105 = arg$1.mem$square;
    final int a3$8104 = arg$1.mem$col;
    final int a2$8103 = arg$1.mem$row;
    final int a1$8102 = arg$1.mem$cellNumber;
    return TUnknown.mk(a1$8102, a2$8103, a3$8104, a4$8105, (int)arg$2.apply(Thunk.<Integer>lazy(arg$1.mem$possible)).call());
  }
  final public static int cellNumber(final TUnknown arg$1) {
    final int a1$8046 = arg$1.mem$cellNumber;
    return a1$8046;
  }
  final public static TUnknown chg$cellNumber(final TUnknown arg$1, final Func.U<Integer, Integer> arg$2) {
    final int a5$8064 = arg$1.mem$possible;
    final int a4$8063 = arg$1.mem$square;
    final int a3$8062 = arg$1.mem$col;
    final int a2$8061 = arg$1.mem$row;
    return TUnknown.mk((int)arg$2.apply(Thunk.<Integer>lazy(arg$1.mem$cellNumber)).call(), a2$8061, a3$8062, a4$8063, a5$8064);
  }
  final public static <α> boolean has$cellNumber(final Lazy<α> arg$1) {
    return true;
  }
}
final public static TUnknown removeDigitFromPossible(final int arg$1, final TUnknown arg$2) {
  return TUnknown.upd$possible(arg$2, Bits.IBits_Int.clearBit(TUnknown.possible(arg$2), arg$1 - 1));
}
final public static int numPossible(final TUnknown arg$1) {
  return Integer.bitCount(TUnknown.possible(arg$1));
}
final public static TUnknown $new(final int arg$1) {
  final int col$8152 = PreludeBase.IIntegral_Int.mod(arg$1, 9);
  final int row$8151 = PreludeBase.IIntegral_Int.div(arg$1, 9);
  return TUnknown.mk(
            arg$1, row$8151, col$8152,
            (PreludeBase.IIntegral_Int.div(row$8151, 3) * 3) + PreludeBase.IIntegral_Int.div(col$8152, 3), 0x1FF
          );
}
final public static boolean isExcludedBy(final TUnknown arg$1, final TUnknown arg$2) {
  return (TUnknown.cellNumber(arg$1) != TUnknown.cellNumber(arg$2)) && ((TUnknown.row(
            arg$1
          ) == TUnknown.row(arg$2)) || ((TUnknown.col(arg$1) == TUnknown.col(arg$2)) || (TUnknown.square(
            arg$1
          ) == TUnknown.square(arg$2))));
}
final public static boolean isDigitPossible(final int arg$1, final TUnknown arg$2) {
  return Bits.IBits_Int.testBit(TUnknown.possible(arg$2), arg$1 - 1);
}
final public static TUnknown place(final Lazy<Integer> arg$1, final int arg$2, final TUnknown arg$3) {
  if (Unknown.isDigitPossible(arg$2, arg$3)) {
    if (Unknown.isExcludedBy(arg$3, Unknown.$new((int)arg$1.call()))) {
      return Unknown.removeDigitFromPossible(arg$2, arg$3);
    }
    else {
      return arg$3;
    }
  }
  else {
    return arg$3;
  }
}
final public static PreludeBase.TList<Integer> getPossibleList(int arg$1, Lazy<Integer> arg$2) {
  tailrecursion: while (true) {
    final int arg$1f = arg$1;
    final Lazy<Integer> arg$2f = arg$2;
    if (0 == arg$1f) {
      return PreludeBase.TList.DList.<Integer>mk();
    }
    if (Bits.IBits_Int.testBit(arg$1f, 0)) {
      return PreludeBase.TList.DCons.<Integer>mk(
                arg$2f,
                Thunk.<PreludeBase.TList<Integer>>shared(
                      new Lazy.D<PreludeBase.TList<Integer>>() {
                        public PreludeBase.TList<Integer> call() {
                          return Unknown.getPossibleList(
                                    arg$1f >> 1,
                                    Thunk.<Integer>shared(
                                          new Lazy.D<Integer>() {
                                            public Integer call() {
                                              return (int)arg$2f.call() + 1;
                                            }
                                          }
                                        )
                                  );
                        }
                      }
                    )
              );
    }
    else {
      arg$1 = arg$1f >> 1;
      arg$2 = Thunk.<Integer>shared(new Lazy.D<Integer>() {public Integer call() {return (int)arg$2f.call() + 1;}});
      continue tailrecursion;
    }
  }
}
final public static PreludeBase.TList<Integer> getPossible(final TUnknown arg$1) {
  return Unknown.getPossibleList(TUnknown.possible(arg$1), Thunk.<Integer>lazy(1));
}

}
